name: CI PIPELINE-(DEV)

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Image Version Tag'
        required: true
        default: 'v-1'

jobs:
  # STAGE 1: Security Scanning with GitLeaks
  security-scan:
    name: Security Scan
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4  # Updated from v3 to v4
      
      - name: Run GitLeaks Scan
        uses: gitleaks/gitleaks-action@v2
        with:
          fail_build: true
          verbose: true
  
  # STAGE 2: Build with Maven
  build:
    needs: security-scan
    name: Maven Build
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4  # Updated from v3 to v4
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4  # Updated from v3 to v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Build with Maven
        run: mvn clean install
      
      # We need to make the build artifacts available for the next jobs
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4  # Updated from v3 to v4
        with:
          name: app-artifacts
          path: target/*.jar
  
  # STAGE 3: SonarQube Code Quality Scan
  code-quality:
    needs: build
    name: SonarQube Analysis
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Shallow clones should be disabled for better relevancy of analysis
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: app-artifacts
          path: target
      
      - name: SonarQube Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          # Run SonarQube scan using Docker container
          docker run --rm \
            -e SONAR_HOST_URL="${SONAR_HOST_URL}" \
            -e SONAR_LOGIN="${SONAR_TOKEN}" \
            -v "$(pwd):/usr/src" \
            sonarsource/sonar-scanner-cli:latest \
            -Dsonar.projectKey=pk-app-1 \
            -Dsonar.projectName="PK App 1" \
            -Dsonar.java.binaries=target \
            -Dsonar.sources=src \
            -Dsonar.java.source=17 \
            -Dsonar.sourceEncoding=UTF-8
          
          echo "SonarQube analysis completed"

  # STAGE 4: Build Docker Image
  docker-build:
    needs: [build, code-quality]  # Now depends on both build and code-quality
    name: Docker Build
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: app-artifacts
          path: target
      
      - name: Configure Google Cloud Auth
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: '${{ secrets.GCP_SERVICE_ACCOUNT }}'
      
      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v1'
      
      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker us-central1-docker.pkg.dev --quiet
      
      # Push JAR files to GCR as artifacts
      - name: Push JAR to Artifact Registry
        run: |
          echo "Uploading JAR files to Artifact Registry..."
          # Create directory for storing JAR files
          mkdir -p jar-artifacts
          cp target/*.jar jar-artifacts/
          
          # Upload JAR files to GCR
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          JAR_PREFIX="us-central1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/pk-docker-repo-dev/jars"
          
          for jarfile in jar-artifacts/*.jar; do
            JARNAME=$(basename "$jarfile")
            echo "Uploading $JARNAME to Artifact Registry..."
            gcloud artifacts jars upload "$JAR_PREFIX/$JARNAME" \
              --source="$jarfile" \
              --location=us-central1 \
              --project=${{ secrets.GCP_PROJECT_ID }} || echo "Failed to upload JAR"
          done
      
      - name: Build Docker image
        env:
          IMAGE_NAME: "us-central1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/pk-docker-repo-dev/app-1"
          IMAGE_TAG: "${{ github.event.inputs.version }}"
        run: |
          echo "Building image: ${IMAGE_NAME}:${IMAGE_TAG}"
          docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .
  
  # STAGE 5: Push to Registry
  deploy:
    needs: docker-build
    name: Push to Registry
    runs-on: self-hosted
    steps:
      - name: Configure Google Cloud Auth
        uses: 'google-github-actions/auth@v1'
        with:
          credentials_json: '${{ secrets.GCP_SERVICE_ACCOUNT }}'
      
      - name: Set up Cloud SDK
        uses: 'google-github-actions/setup-gcloud@v1'
      
      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker us-central1-docker.pkg.dev --quiet
      
      - name: Push Docker image
        env:
          IMAGE_NAME: "us-central1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/pk-docker-repo-dev/app-1"
          IMAGE_TAG: "${{ github.event.inputs.version }}"
        run: |
          echo "Pulling image before push: ${IMAGE_NAME}:${IMAGE_TAG}"
          docker pull ${IMAGE_NAME}:${IMAGE_TAG} || echo "Image not found locally, will be built and pushed"
          echo "Pushing image: ${IMAGE_NAME}:${IMAGE_TAG}"
          docker push ${IMAGE_NAME}:${IMAGE_TAG}
  
  # STAGE 5: Cleanup
  cleanup:
    needs: deploy
    name: Cleanup Resources
    runs-on: self-hosted
    if: always()  # Run even if previous steps fail
    steps:
      - name: Clean Docker images
        run: |
          echo "Cleaning up Docker resources..."
          # Get the image name from previous steps
          IMAGE_NAME="us-central1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/pk-docker-repo-dev/app-1:${{ github.event.inputs.version }}"
          
          # Remove the Docker image
          echo "Removing Docker image: ${IMAGE_NAME}"
          docker rmi ${IMAGE_NAME} || echo "Image ${IMAGE_NAME} not found or already removed"
          
          # Clean dangling images
          echo "Cleaning dangling images..."
          docker image prune -f
          
          # Clean build cache
          echo "Cleaning build cache..."
          docker builder prune -f --filter until=24h
          
          echo "Cleanup completed"
      
      